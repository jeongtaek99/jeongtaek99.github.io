---
layout: single
title:  "[소프트웨어공학] 시스템 모델링2"
categories: "소프트웨어공학"
tag: [blog, jekyll, Software_engineering, 소프트웨어공학]
---
<br><br>


># 구조모델

소프트웨어의 구조적 모델은 시스템을 구성하는 ***구성요소와 그 관계의 측면***에서 시스템의 조직을 표시한다.

- ***정적모델*** : 시스템 설계의 구조를 보여주는 정적 모델

- ***동적 모델*** : 시스템이 실행 중일 때 시스템 구성을 보여주는 동적 모델.

구조모델은 결국 ***시스템 아키텍처***를 논의하고 설계할 때 만든다.
<br><br>

## Class 다이어그램

클래스 다이어그램은 시스템의 클래스들과 그들 간의 연관을 보여주는 ***객체지향 시스템*** 모델을 개발할 때 사용된다.

- 연관은 클래스들 사이에 어떤 관계가 있다는 것을 표시하는 클래스 사이의 ***연결***이다.

- 소프트웨어 공학 프로세스의 초기 단계(전반부)에서 모델을 개발할 때, 객체들은 환자, 처방, 의사 등과 같이 실세계의 무엇인가를 표현한다.
<br><br>

>Class 다이어그램의 예시
 
> ![](/images/swe/19.png)
 
> ![](/images/swe/20.png)
<br><br>

### 객체를 보여주는 클래스

클래스들 사이의 연관을 보여줄 때 클래스들을 속성과 오퍼레이션을 표시하지 않고 가능한 단순하게 보여주는 것이 최선이다. 객체를 더 상세하게 정의하려면 속성(객체의 특성)과 오퍼레이션(객체의 함수)에 관한 정보를 추가한다.
> ![](/images/swe/21.png) 

1. 제일 윗부분은 객체 클래스의 이름이다.

2. 중간 부분은 클래스 속성들이다. 여기에는 속성 이름과 선택적으로 속성의 유형을 포함한다.

3. 객체 클래스와 연관된 오퍼레이션(Java와 다른 객체지향 프로그래밍 언어에서 메서드라고 불림)은 사각형의 제일 아랫부분이다.
<br><br>

## 일반화

일반화는 복잡성을 관리하는 데 사용하는 일상적인 기술이다. 우리가 경험하는 모든 엔터티의 세부적인 특성을 배우기보다는 이러한 엔터티를 보다 일반적인 클래스(동물, 자동차, 집 등)에 배치하고 이러한 클래스의 특성을 학습한다.

- 이를 통해 이러한 클래스의 다른 구성원이 몇 가지 공통된 특성을 가지고 있음을 추론할 수 있다(Ex. 다람쥐와 쥐는 설치류이다.).

- Java와 같은 객체 지향 언어에서 일반화는 언어에 내장된 클래스 ***상속 메커니즘***을 사용하여 구현된다.

- 일반화에서 상위 수준 클래스와 관련된 속성 및 작업은 하위 수준 클래스와도 연결된다.

- 하위 클래스는 상위 클래스에서 특성과 작업을 상속하는 하위 클래스다. 이러한 하위 수준 클래스는 보다 구체적인 특성과 작업을 추가합니다.
<br><br>

> ![](/images/swe/22.png)

<br><br>

## 집합

UML은 집합 (aggregation)이라고 불리는 특별한 유형의 클래스들 간 연관을 제공하는데, 이는 한 객체(전체)가 다른 객체들(부분)로 구성된다는 것을 의미한다. 집합을 정의하기 위해서 전체에 해당하는 객체 쪽 연결에 마름모 모양을 추가한다.
 
> ![](/images/swe/23.png)

<br><br>

## 시퀀스(Sequence) 다이어그램

상호작용 다이어그램중 시퀀스 다이어그램과 통신 다이어그램이 있다. 이중 시퀀스 다이어그램은 UML의 일부이며 ***액터와 시스템 내의 개체 간의 상호 작용***을 모델링하는 데 사용된다.

- 특정 사용 사례 또는 사용 사례 인스턴스 중에 발생하는 상호 작용 시퀀스를 시간순으로 보여줌.

- 관련된 ***객체와 액터***는 다이어그램의 상단을 따라 나열되며 이들로부터 수직으로 점선이 그려짐

- 즉, 유스케이스의 기능을 객체와 메시지를 통해 구현

- 개체 간의 상호 작용은 주석이 달린 화살표로 표시됨
 
> ![](/images/swe/24.png)

<br><br>

### 객체
<br>

1. 시퀀스 다이어그램의 맨 위에 위치하며 왼쪽에서 오른쪽으로 배열
<br><br>

2. 객체의 생명선(Lifeline)
   - 각 객체에서 아래로 뻗어나가는 점선
<br><br>
3. 활성화 부분
   - 생명선을 따라 드문드문 나타나는 작은 사각형
   - 객체가 수행하는 오퍼레이션이 실행되고 있음을 나타냄
   - 활성화의 길이는 오퍼레이션의 실행 소요 시간을 나타냄
<br><br>

### 메시지

호출 메시지(call)
- 송신 객체가 수신 객체로 보내는 메시지로 동기 메시지라고 부름

답신 메시지(reply)
- 호출 메시지와 화살표 머리모양이 같으며 점선형태

비동기 메시지(asychronous)
- 송신 객체가 보냄
- 수신 객체의 오퍼레이션을 실행시키거나 완료될 때까지 송신 객체가 기다리지 않음
 
> ![](/images/swe/25.png)
 
> ![](/images/swe/26.png)



<br><br>

### 예제 : 식당 음식 주문
1. 고객이 종업원에게 음식을 주문(orderFood)
2. 종업원은 요리사에게 주문받은 음식의 조리를 요청(demandFood).
3. 요리사는 짜장면을 조리(makeFood, getFood)
4. 요리사가 만든 요리를 종업원에게 전달(deliveryFood)
5. 종업원이 음식을 고객에게 전달(Serve)

시퀀스 다이어그램
> ![](/images/swe/27.png)
 
<br><br>

### 예제 : 영화 예매
사용자(User), 매표소(Box Office), 신용카드회사(Credit Card Service)
- 사용자가 매표소에 예매할 영화의 정보를 요구(Request)
- 매표소에서 사용자에게 이용가능한 좌석을 보임(show availability)
- 사용자가 좌석을 선택해 매표소에 알림(select)
- 매표소에서 사용자에게 결제금액을 알림(demand payment)
- 사용자가 카드를 삽입(insert card)
- 매표소에서 결제금액을 신용카드회사에 청구(charge)
- 신용카드회사에서 매표소의 거래요청을 승인(authorized)
- 매표소에서 사용자가 결제한 티켓을 출력(print ticket)

시퀀스 다이어그램
> ![](/images/swe/28.png)
 


<br><br><br>

># 동작모델

동작 모델은 시스템이 실행될 때의 ***동적 행동***에 대한 모델이다. 이것은 시스템이 환경의 자극에 반응할 때 무엇이 일어나는지 또는 무엇이 일어나도록 의도되었는지를 보여준다. 이와 같은 자극은 ***데이터일 수도 있고 이벤트***일 수도 있다.
<br><br>

## 데이터 기반(Data-driven) 모델링

데이터 주도 모델은 입력 데이터의 처리와 이와 연관된 출력 생성과 관련된 일련의 행동들을 보여준다.

- 이것은 처음부터 끝까지 시스템의 처리과정을 보여주므로 요구사항 분석 중에 사용될 수 있다.

-  즉, 이것은 최초의 입력 처리와 이에 따른 출력부터 시스템이 ***반응하여 일어나는 행동 전체***를 연속으로 보여준다.
<br><br>

## 이벤트 주도 모델링
이벤트 주도 모델링은 어떻게 시스템이 외부와 내부 이벤트에 반응하는지를 보여준다.

- 실시간 시스템은 종종 최소한의 데이터 처리로 이벤트 기반이다.

- 그것은 시스템이 유한한 수의 상태를 가지고 있고 이벤트(자극)가 한 상태에서 다른 상태로 전이를 유발할 수 있다는 가정을 기반으로 합니다.
<br><br>

### 상태 머신 모델

상태 머신 모델은 외부 및 내부 이벤트에 대한 응답으로 시스템의 동작을 모델링한다.

- 이는 자극에 대한 시스템의 반응을 보여주므로 종종 실시간 시스템을 모델링하는 데 사용된다.

- 상태 시스템 모델은 시스템 상태를 노드로 표시하고 이벤트를 이러한 노드 사이의 아크로 표시한다(이벤트가 발생하면 시스템이 한 상태에서 다른 상태로 이동.).
<br>

>상태다이어그램 (Ex. 마이크로 오븐)
> ![](/images/swe/29.png)
> ![](/images/swe/30.png)



## 모델 주도 공학(MDE : model-driven engineering)

모델 주도 공학은 프로그램보다 모델이 개발 프로세스의 주요 출력물인 소프트웨어 개발 접근법이다.

- 하드웨어/소프트웨어 플랫폼에서 실행되는 프로그램은 모델로부터 자동으로 생성된다

- 모델 주도 공학 지지자들은 이것이 소프트웨어 공학에서 추상화 수준을 올림에 따라 엔지니어들이 더 이상 프로그래밍 언어의 상세 내역이나 실행 플랫폼의 특성에 관여할 필요가 없다고 주장한다.
<br><br><br>

># 모델 주도 아키텍쳐(MDA : model-deriven architecture)

<br>
MDE는 소프트웨어 공학 프로세스의 모든 면과 연관되어있는 반면, MDA는 소프트웨어 개발의 설계와 구현 단계에 초점을 둔다.
<br><br>

모델 주도 아키텍처는 시스템을 기술하기 위하여 UML 모델의 일부를 사용하는 소프트웨어 설계와 구현에 대한 모델 중심 접근법이다.
<br><br>

## MDA 방법의 세가지 유형의 추상 시스템 모델
<br>

***계산 독립 모델(CIM : computation independent model)***
- CIM은 시스템에서 사용되는 중요한 도메인 추상화를 모델링해서 때때로 도메인 모델이라고 불린다. 시스템의 서로 다른 관점을 반영하는 여러 개의 서로 다른 CIM을 개발할 수 있다.
<br><br>

***플랫폼 독립 모델(PIM: platform-independent model)***
- PIM은 구현을 참조하지 않고 시스템의 동작을 모델링한다.
<br><br>

***플랫폼 특화 모델(PSM: platform-specific models)***
- PSM은 각 응응 플랫폼별로 플랫폼 독립 모델을 변환한 것이다. 원칙적으로 각 계층에서 플랫폼에 특화된 세부 사항을 추가하는 PSM 계층들이 존재할 수 있다.
파악하는데 중점
