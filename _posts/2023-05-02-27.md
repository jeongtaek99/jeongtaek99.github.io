---
layout: single
title:  "[자료구조] 트리 - Trees(Part I)"
categories: "자료구조"
tag: [blog, jekyll, data_structure, 자료구조, c++]
---
<br><br>


># 트리 - Trees

***트리란?***

- 트리는 비선형 구조다.
- 즉, 구성요소는 첫번째 엔트리, 두 번째 엔트리, 세 번째 엔트리등의 단순한 시퀀스를 형성하지 않는다.
- 체인처럼 연결된 구조가아닌 가지가 뻗어나가는 구조다.
- 트리에는 비어 있을 수 있는 한정된 노드 집합이 있다.
- 한 종류 또는 다른 종류의 데이터는 각 노드에 저장될 수 있다.

> ![](/images/datas/18.png)

<br><br>

## Definitions

***Parent (of a node)***
- 노드 위에 연결된 노드

<br>

***Child(ren) (of a node)***
- 노드 아래에 연결된 노드

<br>

***Siblings***
- 부모가 같은 노드(형제)

<br>

***Root (of a tree)***
- 부모가 없는 특수 노드

<br>

***Leaf***
- 자식이 없는 노드

<br>

***Ancestor (of a node)***
- 노드의 부모는 조상
- 부모의 모든 조상은 조상

<br>

***Descendant (of a node)***
- 노드의 자식은 그 자손
- 자녀의 모든 후손은 그 후손

<br>

***Subtree (of a tree)***
- 원래 트리 내의 더 작은 트리

<br>

***Depth of a node(노드의 깊이)***
- 노드에서 루트까지의 단계 수

<br>

***Depth of a tree(트리의 깊이)***
- leaves의 가장 큰 깊이

<br>

## Definitions

node | Definitions

Parent | 노드 위에 연결된 노드
Child(ren) | 노드 아래에 연결된 노드
Siblings | 부모가 같은 노드(형제)
Root (of a tree) | 부모가 없는 특수 노드
***Leaf*** | 자식이 없는 노드
***Ancestor (of a node)*** | 노드의 부모는 조상, 부모의 모든 조상은 조상
***Descendant (of a node)*** | 노드의 자식은 그 자손, 자녀의 모든 후손은 그 후손
***Subtree (of a tree)*** | 원래 트리 내의 더 작은 트리
***Depth of a node(노드의 깊이)*** | 노드에서 루트까지의 단계 수
***Depth of a tree(트리의 깊이)*** | leaves의 가장 큰 깊이

<br><br>

## Binary Trees

바이너리 트리

- 각 노드는 최대 두 개의 자식(왼쪽 자식과 오른쪽 자식)을 가질 수 있음
- 노드의 왼쪽 아래 트리는 루트가 왼쪽 자식인 하위 트리
- 노드의 오른쪽 아래 트리는 루트가 오른쪽 자식인 하위 트리

***Full Binary Trees***는 모든 리프가 동일한 깊이이며 리프가 아닌 노드는 두개의 자식이 있는 트리다.

<br>

***Complete Binary Trees***는 가장 깊은 레벨에는 가능한 많은 노드가 포함되어야 하고 모든 노드는 가능한 한 멀리 왼쪽에 있어야 한다.

Ex. 다음은 complete 인가? -> no

>![](/images/datas/19.png){: .align-center .image-width-half}

<br>

Ex. 다음은 complete 인가? -> yes

>![](/images/datas/20.png){: .align-center .image-width-half}

<br><br>

## Tree Representations

트리를 표현하는 방법

1. 이진 트리의 배열 표현을 한다.

>![](/images/datas/21.png){: .align-center}

자세히 살펴보면 트리의 수식을 확인할 수 있다.
- left child : [2i + 1]
- left child : [2i + 2]

<br>

2. 노드 클래스로 이진 트리를 표현한다.

>![](/images/datas/21.png){: .align-center}

다음은 3가지 멤버 변수를 갖는다.

- data_field : 데이터 저장을 위해
- left_field : 왼쪽 자식 노드에 대한 포인터
- right field : 오른쪽 자식에 대한 포인터

<br><br>

## 바이너리 트리 노드

<br>

### 클래스 구현
***

***constructor***

```c++
binary_tree_node(
	const Item& init_data = Item(),
	binary_tree_node* init_left = NULL,
  binary_tree_node* init_right = NULL)
{    
	data_field  = init_data ;
	left_field = init_left ;
	right_field = init_right ;
} 
```

<br>

***data***

```c++
Item& data( ) //&는 n->data=42;라는 표현도 가능하다.
// 보통은 Item a = n.data();
{    
  return data_field ;
} 
```

<br>

***left***

```c++
binary_tree_node*&  left( )
{    
	return left_field ;
}
```

<br>

***right***

```c++
binary_tree_node*& right( )
{    
	return right_field ;
} 
```

<br>

***set_data(...)***
```c++
void set_data(const item& new_data) { data_field = new_data ;}
```

<br>

***set_left(...)***
```c++
void set_left(binary_tree_node* new_left) { left_field = new_left ; } 
```

<br>

***set_right(...)***
```c++
void set_right(binary_tree_node* new_right) { right_field = new_right ; } 
```

***is_leaf()***
```c++
bool is_leaf( ) const 
{
	return (left_field == NULL &&
					right_field == NULL) ;
}
```

<br><br>

### 트리 함수들
***

***tree_clear***
```c++
template <class Item>
void tree_clear(binary_tree_node<Item>*& root_ptr)
{
	if(root_ptr != NULL)
	{
		tree_clear(root_ptr -> left());
		tree_clear(root_ptr -> right());
		delete root_ptr;
		root_ptr = NULL;
	}
} 
```

