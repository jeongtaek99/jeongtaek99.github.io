---
layout: single
title:  "[리눅스]리눅스 필수 개념과 명령어."
categories: "리눅스"
tag: [blog, jekyll, Linux, 리눅스, 우분투, ubuntu]
---
# 우분투 리눅스 필수 개념과 명령어
{: .notice--info}

# 1. 리눅스 운영 시 숙지 개념

## 리눅스 시작과 종료
<p>시작 : virtualBox 시작
<br>종료 :
<br>GUI – 컴퓨터 끄기
<br>TUI – 명령어 ‘poweroff’, ‘shutdown -P now’, ‘halt -p’, ‘init 0’
<br><br># shutdown –P +10 : 10분 종료(P: poweroff)
<br># shutdown –r 22:00 : 오후10시에리부팅(r:reboot)
<br># shutdown –c : 예약된shutdown 취소(c:cancel)
<br># shutdown –k +15 : 현재 접속자들에게 15분후 종료메시지 방송, 종료는 안됨</p>

### 시스템 종료 시 주의사항
<p>리눅스는 시스템이 종료될 때까지 커널 메모리 상에 프로세스들이 작동하고 있기 때문에 프로세스를 중지하지 않고 전원을 끄면 파일 시스템에 심각한 결함을 준다. 따라서 반드시 명령어로 시스템을 종료해야 한다.</p>

### 시스템 리부팅
<p>GUI – 리부팅 없음
<br>TUI – 명령어 reboot, shutdown -r now, init 6</p>

### 로그아웃
<p>로그아웃은 현재 사용자가 시스템 접속을 끊는 것으로
<br>GUI – 로그아웃
<br>TUI – 명령어 logout, exit</p>
<br>

## 가상콘솔
<p>한 대의 컴퓨터에 모니터가 7개 연결된 효과로 서버 부팅하면 자동으로 X윈도 실행(2번째 콘솔), 나머지(3번 ~ 6번)는 텍스트 모드로 제공한다(총 6개의 가상콘솔 제공 – 2번~7번).
<br>텍스트 모드 : 가상콘솔 생성 키 – Ctrl + Alt + F4~F6
<br>x 윈도 콘솔 키 : Ctrl + Alt +F2</p>

### 가상콘솔 실습
<p>일반사용자 생성 : root권한으로 adduser 사용자명 실행 – 정보 입력 후 가상 콘솔 열고 Ctrl+Alt+F3 – 사용자명 으로 로그인해서 실습하다가 x윈도 터미널로 돌아오고 싶으면 Ctrl+Alt+F2 를 입력한다.
<br>who – 명령어를 입력하면 루트사용자가 현재 로그인된 사용자를 확인 할 수 있다.</p>
<p>서버 관리자가 10분 후 shutdown하는 명령 방송하기 및 취소하기
<br># shutdown -k +10, shutdown -C</p>
<p>adduser 명령으로 생성된 사용자 정보와 일반 사용자 디렉토리 확인
<br># cat /etc/passwd (cat : 파일의 내용을 화면에 보여주기, etc : 루트아래 환경설정 디렉토리)</p>

## 런레벨(runlevel)
<p>리눅스 시스템의 가동되는 방법 7가지(0~6)로 # init 숫자로 지정 가능하다(# init 0, # init 6).
<br>0 : Power Off
<br>1 : Single-User Mode(Rescue) – 응급복구시 사용
<br>2 : Multi-User Mode(Not used)
<br>3 : Multi-User(Text mode) – CLI 모드
<br>4 : Not used
<br>5 : Multi-User mode(X window mode) - GUL모드 – 멀티+그래픽
<br>6 : Reboot
<br> - 런레벨 2,4는 사용하지 않지만 호환성을 위해 런레벨 3번과 동일하게 취급한다.</p>

### 런레벨 종류 확인
<p># cd /lib/system/system;
<br># ls -l runlevel?.target; 명령 입력시 0~6번까지 런레벨의 종류를 확인할 수 있다.
<br>현재 런레벨 확인하는 법은 # ls -l /lib/system/system/default.target 입력하면 확이할 수 있다.</p>

<p>텍스트 모드 변경
<br>1. ln -sf /lib/systemd/system/multi-user.target /lib/systmd/system/default.target
<br>2. ls –l /lib/systemd/system/default.target
<br>3. reboot
<br>다시 x윈도 모드로 변경하려면 default.target을 graphicl.target으로 부팅되게 변경한다.</p>

<p>자동완성과 히스토리 기능
<br>자동완성 기능 : 파일명이 긴 경우 일부분만 입력 후 Tab키를 이용해 자동완성하는 기능이다.
<br>히스토리 기능 : 상 하 화상표키를 이용해 이전 명령어를 사용하는 기능이다.</p>

## 에디터 사용
<p>X윈도우 에디터 : gedit-프로그램 표시 – 텍스트 편집기(윈도우 메모장과 유사)
<br>텍스트 환경 에디터 : vi(vim)은 유닉스와 리눅스에 기본적으로 포함</p>

### vi에디터 실습
<p>설치 : # apt-get install vim
<br>사용법 : 모드형의 경우
<br>입력모드 : ‘I’키를 눌러 텍스트 입력이 가능
<br>명령모드 : ‘복사(yy)’, ‘붙이기(p)’, ‘저장(:wq)’
<br>모드전환 : ‘i’
<br>특정 행으로 커서이동 : ‘행번호G(shift+g)’, ‘:행번호(enter)’
<br>내용 삭제하는 키 : ‘dd’, ‘삭제할 행의 수dd’
<br>이전 명령 취소 키 : ‘u’
<br>검색하기 키 : ‘/문자열’(문자열 아래방향으로 검색), ‘?문자열’(위 방향으로 검색) 
<br>바꾸기 키(마지막행 모드에서) : ‘%s/문자열1/문자열2/g’(파일전체에서 1->2로 변환)
<br>현재커서 위치에 다른파일 내용 삽입 : ‘:r 파일명’
<br>지정한 파일로 전환(기존파일 저장 후) : ‘:e 파일명’</p>
<p>etc
<br>: ! – 1회 셀 명령 사용가능, 다시 돌아가려면 enter
<br>: sh – 여러 번 셀 명령 사용가능, 다시 돌아가려면 exit</p>

## vi의 환경변수
<p>set 명령과 옵션
<br>set nu : 파일의 각 행에 번호를 표시(보이기만)
<br>set nonu : 행 번호 감추기
<br>set list : 눈에 보이지 않는 특수 문자를 표시한다
<br>set nolist : 특수 문자를 감춘다
<br>set showmode : 현재 모드를 표시한다.
<br>set noshowmode : 현재 모드를 감춘다.
<br>set : set으로 설정하는 모든 vi 환경 설정 값을 출력한다.
<br>set all : 모든 vi 환경 변수와 현재 값을 출력한다.
<br>set hlsearch : 검색어 하이라이팅
<br>set autoindent : 자동 들여쓰기
<br>set history=256 : 이전 사용 명령어 저장
<br>set laststatus=2 : 상태바 표시 항상
<br>set ruler : 현재 커서 위치 표시</p>
<p>도움말 사용법
<br>이처럼 리눅스 운영체제의 명령어는 수 천개가 넘는다. 모두 암기가 불가능하므로 도움말을 이용해야 한다.</p>

### man(manual) 명령 – section
<p>1 : 명령어
<br>2, 3 : 프로그래밍
<br>4 : 디바이스
<br>5 : 파일 형식
<br>6 : 게임
<br>7 : 기타 주제
<br>8 : 시스템 관리
<br>9 : 커널 관련 설명
<br># man ls ; ls 명령에 대한 매뉴얼 페이지 표시, # man 1 ls</p>

# 2. 리눅스 기본 명령어
## 리눅스 명령의 구조
<p>형식은 ‘명령 [옵션] [인자]’ 구조이다. 옵션은 명령의 세부 기능을 선택하는 것이고 인자는 명령으로 전달되는 값으로 주로 파일명이나 디렉토리명이 사용된다.
<br>Ex: ls -a /tmp (ls는 리스트 명령어고 -a는 히든파일까지 보여주는 옵션, /tmp는 해당 디렉토리에서라는 인자다.)</p>
<p>date 명령 – 현재 날짜와 시간을 출력
<br>clear 명령 – 현재 보이는 화면을 지우고 커서를 좌측 상단으로 이동
<br>man 명령 – 각종 명령의 사용법을 알려주는 manual을 보여준다.
<br>passwd 명령 – 사용자 계정의 비밀번호 변경</p>

## 리눅스 파일의 종류와 특징
 
### 파일의 종류
<p>파일이란 관련 있는 정보들의 집합으로 리눅스는 효과적으로 관리하기 위해 디렉토리 개념을 사용한다. <br>리눅스에서는 파일을 사용목적에 따라 일반파일, 디렉토리, 심볼릭 링크, 장치파일로 구분한다.
<br>일반 파일 : 데이터를 저장하는데 사용하며 각종 텍스트 파일, 실행파일등 대부분의 파일들이다.
<br>디렉토리 : 리눅스에서 디렉토리도 파일로 취급한다. 디렉토리에는 해당 디렉토리에 저장된 파일이나 하위 디렉토리에 대한 정보가 저장
<br>심볼릭 링크 : 원본 파일을 대신해 다른이름으로 파일명을 지정한 것(윈도우 바로가기와 유사)
<br>장치 파일 : 리눅스에서는 하드디스크나 키보드, 프린터등 각종 장치들도 파일로 취급</p>

### 디렉토리 계층 구조
<p>리눅스는 파일을 효율적으로 관리하기 위해 디렉토리를 계층적으로 구성 -> 트리구조 모든 디렉토리의 출발점은 루트 디렉토리이며, ‘/’로 표시한다. 상위 디렉토리는 ‘.’으로 표시한다.</p>

<p>작업 디렉토리 : 현재 사용중인 디렉토리로 현재 디렉토리하고 함, ‘.’ 기호로 표시한다.(pwd명령으로 확인가능)
<br>홈 디렉토리 : 각 사용자에게 할당된 디렉토리로 ‘~’기호로 표시한다.</p>

### 주요 디렉토리의 기능
<p>dev : 장치파일이 담긴 디렉토리
<br>home : 사용자 홈 디렉토리가 생성되는 디렉토리
<br>var : 데이터나 로그 등이 저장되는 디렉토리
<br>root : root계정의 홈 디렉토리, ‘/’디렉토리와 다른 디렉토리다.
<br>sys : 리눅스 커널과 관련된 파일이 있는 디렉토리
<br>usr : 기본 실행파일과 라이브러리 파일등 많은 파일 저장
<br>boot : 부팅에 필요한 커널이 있는 디렉토리
<br>etc : 리눅스 설정을 위한 각종 파일이 있는 디렉토리
<br>mnt : 파일 시스템을 임시로 마운팅 하는 디렉토리
<br>tmp : 시스템 사용 중에 발생하는 임시 데이터가 저장, 리부팅하면 모두 삭제</p>

### 파일과 디렉토리 이름 규칙
<p>파일과 디렉토리 이름에는 알파벳, 숫자, 붙임표(-), 및줄(_), 점(.)만 사용한다.
<br>사용하면 안되는 문자 : 공백문자, /, *, |, “, ‘, @, #, $, %, ^, &등
<br>추가로 영문자는 대소문자를 다른 글자로 취급하며 ‘.’으로 시작하면 숨김파일로 간주한다.</p>

## 디렉토리 명령어
### pwd
<p>현재 디렉토리 확인하기</p>

### cd [디렉토리명]
<p>디렉토리 변경하기(디렉토리명을 입력하지 않는경우 해당계정의 홈디렉토리로 이동)</p>

### ls [옵션] [파일 또는 디렉토리 명]
<p>옵션 : -a(히든파일 포함), -i(inode 번호를 출력), -l(상세정보 표시), -F(파일의 종류를 표시), -d(지정한 디렉토리 자체의 정보를 출력), -R(아래 구조를 보여줌)
<br>ls는 리스트를 보여준다.</p>
<p>-F 옵션 사용시 /: 디렉토리, @: 심볼릭 링크, *:실행파일, 표시없음: 일반파일
ls -aF와 같이 숨김파일을 보여주며 파일의 종류를 표시하게 연결하여 사용할 수 있다.
<br>-l 옵션 사용시 “drwxr-xr-x 2 root 4096 1월 16 16:27 snap”다음과 같이 나타나는데 첫번쨰 문자는 파일종류를 나타내는 것으로 -는 일반파일, d는 디렉토리를 나타낸다. 다음 9자는 접근권한을 나타내는데 read, write, execute로 owner/group/others에 대한 읽기 쓰기 실행 권한을 나태내며 -표시가 되어있으면 권한이 없는 것이다. 추가로 ls = dir, ls -a = vdir로 바꿔 사용해도 똑같은 결과값을 볼 수 있다.</p>

### mkdir [옵션] 디렉토리명
<p>옵션 : -p(하위 디렉토리를 생성할 때 중간 디렉토리가 없으면 전체 디렉토리를 생성)
<br>mkdir은 make directory로 디렉토리 만들기다디렉토리명은 상대경로나 절대경로명으로 지정하며 ‘mkdir 디렉토리명 디렉토리명’ 처럼 동시에 여러 디렉토리를 만들 수 있다.</p>

### rmdir [옵션] 디렉토리명
<p>옵션 : -p(지정한 디렉토리를 삭제한 뒤, 그 디렉토리의 부모디렉토리가 빈 디렉토리인경우 부모 디렉토리도 삭제한다.)
<br>만약 디렉토리가 비어있지 않으면 삭제가 불가하다.</p>

### 배운 명령어로 다음 실습을 실행해보자
<p>1. 현재 위치를 확인하고 홈 디렉토리가 아니면 홈디렉토리로 이동 # pwd # cd
<br>2. 실습을 위한 디렉토리(prt)를 하나 만든다. # mkdir prt # cd /prt
<br>3. Ch2 디렉토리를 만들고 그 디렉토리로 이동해 현재 위치를 확인한다. # mkdir ch2 # cd ch2 # pwd
<br>4. One, two, three 디렉토리를 동시에 삭제한다. # mkdir one two three
<br>5. One 디렉토리 아래 tmp/test 디렉토리를 만든다(tmp 자동생성) # mkdir one/tmp/test
<br>6. Two, three 디렉토리를 동시에 삭제한다. # rmdir two three
<br>7. 실습을 마치고 홈디렉토리로 이동한다. # cd</p>

## 파일다루기 명령어

### cat [옵션] 파일명
<p>옵션 : -n(행 번호를 붙여서 출력한다.)
<br>cat은 텍스트 파일의 내용을 확인할 수 있다.</p>

### more [옵션] 파일명
<p>옵션 : +행번호(출력을 시작할 행 번호를 지정한다.)
<br>more은 화면 단위로 파일 내용 출력할 수 있다. 스페이스바를 누르면 다음화면 출력, 엔터키는 한 줄씩 스크롤, /문자열 – 해당 문자열 검색, q: 종료이다.</p>

### less 파일명
<p>lsee는 파일 내용을 화면단위로 출력하는 more과 같지만 조금 개선된 명령어다.
<br>키는 i : 한 줄씩 다음 행으로 스크롤한다. k : 이전행으로 스크롤, 스페이스바 : 다음화면, ^b : 이전 화면
</p>

### tail [옵션] 파일명
<p>옵션 : +행번호(지정한 행부터 끝까지 출력), -숫자(화면에 출력할 행의 수를 지정), -f(파일 출력이 종료되지 않고 주기적으로 계속 출력)
<br>tail은 파일을 출력하는데 뒷부분을 출력한다.</p>

### cp [옵션] 파일명1/디렉토리명1 파일명2/디렉토리명2
<p>옵션 : -i(대화식 복사 방법으로 파일명2가 이미 존재할 경우 덮어쓸 것인지 물어본다.), -r(디렉토리를 복사할 때 사용)
<br>cp는 1번 파일(디렉토리)을 2번파일(디렉토리)로 복사하는 기능이다. 추가로 cp명령에서 첫번째 인자는 여러 개의 파일명을 지정할 수 있는데, 두번째 인자는 반드시 디렉토리여야 한다. 그리고 두번째 인자로 지정한 디렉토리가 이미 있는 디렉토리일 경우, 목적지 디렉토리 아래에 원본 디렉토리와 같은 이름으로 복사한다.

### mv [옵션] 파일명1/디렉토리명1 파일명2/디렉토리명2
<p>옵션 : -i(파일명2/디렉토리명2가 존재하면 덮어씌울것인지 물어본다.)
<br>mv는 move로 파일을 다른 디렉토리로 이동하거나 파일명을 바꿀 때 사용한다. 디렉토리를 이동하거나 디렉토리명을 바꿀 때도 mv 명령을 사용한다. 1번을 2번으로 이동하는 것이다. 2번의 파일이 이미 존재하면 덮어씌우고 없으면 새 파일이 생성된다. 두번째 인자가 디렉토리면 해당 디렉토리로 이동한다. 추가로 rwx중w권한이 없는 파일을 이동하려고 하면 오류가 발생한다. 또한 여러 개의 파일을 한번에 이동도 가능하다.</p>

### rm [옵션] 파일명/디렉토리명
<p>옵션 : -i(대화식으로 지정한 파일을 정말 삭제할 것인지 확인한다.), -r(디렉토리를 삭제할 때 사용한다.)
<br>rm은 remove로 파일 또는 디렉토리를 삭제할 수 있는 명령어다. 삭제된 파일은 복구할 수 없기 때문에 신중해야 한다. rmdir은 디렉토리 안에 파일이 있으면 오류 메시지가 출력하지만 rm 명령어는 바로 삭제되기 때문이다.</p>

## 리눅스 파일의 구성
<p>파일 = 파일명 + inode(indexnode) + 데이터 블록</p>

<p>여기서 파일명은 사용자가 파일에 접근할 때 사용하는 파일의 이름, inode는 파일에 대한 정보를 가지고 있는 특별한 구조체로 외부적으로 번호로 표시되고 내부적으로 파일의 종류 및 크기, 소유자, 파일 변경 시간, 파일명등 파일 상세 정보와 데이터 블록의 주소를 저장한다.
<br>파일의 inode번호는 ls - i 명령으로 확인이 가능하다(파일이름이 달라도 inode가 같으면 같은 파일).</p>

## 파일링크
<p>파일링크는 기존에 있는 파일에 새로운 파일명을 붙이는 것이다.
<br>하드링크 : 기존 파일에 새로운 파일명을 추가로 생성
<br>심볼릭 링크 : 원본 파일을 가리키는 새로운 파일을 생성</p>

### ln [옵션] 원본 파일명 링크 파일명
<p>옵션 : -s 심볼릭 링크 파일을 생성한다.
<br>ln은 파일의 링크를 생성하는 명령어다. 하나의 파일에 여러 개의 이름을 붙일 수 있는데, 이때 붙이는 파일명을 하드링크라고 한다.
<br>링크와 복사의 차이점을 확인해보면 복사는 복사된 파일의 내용을 수정해도 원본은 그래로라는 점이 있다. 옵션 -s를 사용하면 심볼릭 링크를 생성할 수 있다. 이는 원본과 inode가 다르며 ls -l명령을 하면 파일이 ‘->’를 사용해 원본 파일이 무엇인지를 알려준다.</p>

### 심볼릭 링크와 하드링크의 차이점
<p>심볼릭 링크는 하드링크와 비교하여 하드링크의 개수가 하나이며, inode번호가 원본 파일과 다르다. 즉 원본과 심볼릭 링크 파일은 별개의 파일이다. 또한 디렉토리에 심볼릭 링크 생성이 가능하다는 점이 차이점이다. 심볼릭 링크의 추가적인 특징으로 원본파일이 삭제되면 심볼릭 링크로 연결할 수 없다는 점을 주의해야 한다.</p>

## touch [옵션] 파일
<p>옵션 : -a(접근 시간만 변경), -m(수정 시간만 변경), -c(현재시간으로 변경), -t(YYYYMMDDhhmm형식으로 직접 입력), -r(지정한 파일의 날짜시간정보를 지정한 파일의 날짜시간정보와 동일하게 설정 : touch -r oldfile newfile)
<br>touch는 빈 파일을 생성하는 명령어다.</p>

## grep [옵션] 패턴 [파일명]
<p>옵션 : -i(대,소문자를 모두 검색), -l(해당 패턴을 포함하는 파일 이름을 출력), -n(행 번호를 출력한다.)
<br>grep은 파일 내용을 검색해 문자열을 출력해내는 명령어다.</p>

## find 경로검색조건 [동작]
<p>옵션 : 
<br>-name filename : 파일 이름으로 검색
<br>-type 파일종류 : 파일의 종류로 검색(d: 디렉토리, f: 일반파일)
<br>-user loginID : 지정한 사용자가 소유한 모든 파일을 검색
<br>-empty : 빈 파일 검색
<br>-newer : 최근에 변경된 파일 검색
<br>-perm 접근권한 : 지정한 사용 권한과 일치하는 파일을 검색</p>

<p>동작 : 
<br>-exec 명령 {} \; : 검색된 파일에 명렬을 실행
<br>-ok 명령 {} \; : 사용자의 확인을 받아서 명령을 실행
<br>-print : 검색된 파일의 절대 경로명을 화면에 출력
<br>-ls : 검색결과를 긴 목록 형식으로 출력</p>
<p>find 명령은 조건에 맞는 파일을 지정한 위치에서 찾는 명령어다. find명령어만 사용하면 현재 디렉토리(.)에 있는 파일을 찾는다. 접근권한이 없는 디렉토리는 검색이 불가능하다.
<br>중요한 점으로 -delete동작으로 검색 후 삭제가 가능한데 파일과 디렉토리 삭제가 가능하나 빈 디렉토리만 가능하다.</p>

## whereis [옵션] 명령
<p>옵션 : -b(바이너리 실행파일만 검색), -m(매뉴얼 파일만 검색), -s(소스 파일만 검색)
<br>whereis는 지정된 경로에서 명령의 파일의 위치를 찾는다.</p>

## which 명령
<p>명령어 파일의 위치를 찾아서 그 경로나 에일리어스(별칭, 별명)를 출력한다.</p>

# 응급 복구
<p>시스템 관리자라면 위에서 언급했던 run level 0~6을 꼭 알아야 한다. 응급복구는 그중 run level 1번 Single-User Mode(Rescue)이다.
<br>시스템이 부팅이 안되거나 root 비밀번호를 분실했을 경우 사용한다. 사용방법은 boot loader에 들어가 메뉴 클릭 후 edit을 누르고 init = bin/bash(리눅스 기본 쉘)을 입력 후 저장 후 부팅한다.
<br>이때 파티션이 읽기 전용으로 마운트 되어있기 때문에 마운트 상태를 확인하고 파티션의 마운트 상태를 rw상태로 변경 후 root 비밀번호를 변경하여 재시작 해주면 된다.</p>
