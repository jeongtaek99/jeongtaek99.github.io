---
layout: single
title:  "[자료구조] 트리 - Trees(Part 3)"
categories: "자료구조"
tag: [blog, jekyll, data_structure, 자료구조, c++]
---
<br><br>


># 트리 - Trees(Part 3)

아래까지 그림 첨부해야함

<br>

># 힙 - heaps
설명


큐 힙


## 힙에 새 엔트리 추가
1번
2번
따라서



## 힙에서 엔트리 제거

1번
2번
따라서


## 힙 구현




## 총총 및 실습




<>





<br>

># B-Trees

***

**불균형 트리의 문제점**
- 바이너리 서치 트리에서 1, 2, 3, ..., 10을 더하는 경우
- 게속 오른쪽 하위트리가 생성된다.
- 따라서 BST의 장점을 살릴 수 없다.
- 이 경우 B-트리라고 하는 트리를 사용할 수 있다.(AVL tree, red-black tree)

<Br>

## B-tree

B-tree는 각 노드가 어떤 유형의 여러 엔트리를 보유할 수 있는 특별한 종류의 트리다.
- 엔트리 집합을 저장하도록 B-트리를 공식화할 수 있다.
- 대안으로, B-트리는 엔트리 백을 저장하도록 공식화될 수 있다.

<br><br>

## B-tree Rule

단일 노드에 얼마나 많은 항목이 저장되는지를 결정하는 MININUM이라는 양의 정수가 있다.

<br>

**Rule1**
- 루트는 하나의 항목만 가질 수 있다(children이 없다면).
- 다른 모든 노드에는 최소한 MININUM 항목이 있다.

<br>

**Rule2**
- 노드의 최대 항목 수는 MINIMUM 값의 두 배입니다.

<br>

**Rule3**
- 각 B-트리 노드의 항목은 부분적으로 채워진 array에 저장되며 가장 작은 항목(인덱스 0)에서 가장 큰 항목(최종 사용된 인덱스)으로 정렬된다.

<br>

**Rule4**
- 리프가 아닌 노드 아래의 하위 트리 수는 항상 노드의 항목 수보다 하나 많다.
- ex. 42개의 항목이 있는 B-트리 노드는 왼쪽에서 오른쪽으로 하위 트리 0, 하위 트리 1, ..., 하위 트리 42 등 43개의 하위 트리를 갖는다.

<br>

**Rule5**
- 리프가 아닌 노드의 경우
- (a) 인덱스 i에 있는 항목은 노드의 하위 트리 번호 i에 있는 모든 항목보다 크다.
- (b) 인덱스 i에 있는 항목은 노드의 하위 트리 번호 i+1에 있는 모든 항목보다 작다.

<br>

**Rule6**
- B-트리의 모든 리프는 동일한 깊이를 가진다.

<br><br>

## Set ADT with B-trees

B-트리를 사용하는 세트(템플릿) 클래스


엔트리 사이사이에 subtree를 갖고있다.
그림


<br>

**비공개 멤버 상수/변수**

```c++
static const size_t MINIMUM = 200 ;
static const size_t MAXIMUM = 2 * MINIMUM ;
size_t data_count ;
Item data[MAXIMUM+1] ;
size_t child_count ;
set* subset[MAXIMUM+2] ;
```

<br>


## B-Tree를 사용하는 set 함수

<br>

***b-tree의 개념과 insert만 숙지하자***

아래 B-tree의 함수들을 확인해본다.

<Br>

**count function** (searching for an item in a B-tree)
1. 루트에서 data[i]가 target보다 크거나 같은 첫 번째 인덱스 i를 찾는다.
2. If (대상이 data[i]에서 발견되면) return 1 ;
3. else if(루트에 자식이 없는경우) return 0 ;
4. else return subset[i]->count(target) ;

<Br><Br>

### **insert function** (searching for an item in a B-tree)
1. insert할때 두 가지 private 기능을 사용(loose_insert and fix_excess)
2. loose_insert는 다음을 사용하여 B-트리에 새 항목을 추가
3.  루트가 MAXIMUM+1 항목을 가질 수 있는 가능성
4. fix_excess는 하위 트리의 루트에 있는 추가 항목(있는 경우)을 처리

그림 추가55p

<br>

**loose_insert function**

루트가 하나의 추가 항목을 가질 수 있는 방식으로 B-트리에 항목을 삽입

1. In the root, find the first index i such that data[i] >= entry
2. If (entry is found at data[i])  return false;
3. else if (루트에 자식이 없는경우) insert the entry to the root at data[i] and return true ;
4. else { 재귀 호출을 수행하고 초과 문제를 해결 }

- 4.1 bool b = subset[i]->loose_insert(entry) ;
- 4.2 check if the root of subset[i] now has an excess entry ;
- 4.3 If so, fix the subset[i] using the fix_excess function;
- 4.4 return b ;

그림 추가58p

<br>

**fix_excess function**

루트 노드에 일반 B-트리에 대한 추가 항목이 있는 하위 트리(세미-B-트리)를 만듬
- 항목이 MAXIMUM+1인 노드를 각각 MINIMUM 항목이 포함된 두 개의 노드로 분할
- 중간에 있는 항목이 상위로 이동

<br>

**최종 insert funtion**

- If ( ! loose_insert(entry) )
- return false // since entry wasn’t added
- If (data_count > MAXIMUM) 
- fix the root of the entire tree
- return true

<br>

전체트리의 루트를 수정하는 법
- 항목이 없는 새 루트를 만들고 이전 루트를 새 루트의 자식으로 만ema
- 이전 루트에서 fix_excess를 호출

<br><br>

### erase funtion

erase는 B-tree에서 항목을 제거하는 funtion이다.

- loose_erase 및 fix_shortage 두 가지 private를 사용한다.

- loose_erase는 루트에 0개의 항목이 있거나(하나의 하위 항목 포함) 내부 하위 트리의 루트에 최소 항목보다 적은 항목이 있을 수 있는 B-트리에서 항목을 제거

- fix_shortage는 하위 트리의 루트에 있는 항목(있는 경우)의 부족을 처리

1. If ( ! loose_erase(target) )
2. return false // 대상이 제거되지 않았기 때문에
3. If ((data_count == 0) && (child_count ==1))
4. fix the root of the entire tree
5. return true

<br>

**loose_erase funtion**

- 루트가 하나의 항목을 너무 적게 가질 수 있는 방식으로 B-트리에서 항목을 제거합니다.
- 루트에서 data[i] >= entry를 만족하는 인덱스i를 찾는다.
- a : 루트에 자식이 없고 타겟을 찾을 수 없으면 false를 return
- b : 루트에 자식이 없고 타겟을 찾았으면(leaf) 대상을 제거하고 true를 return
- c : else - 루트에 자식이 있는경우
- c1 : 루트에 자식이 있고 타겟을 찾을 수 없는 경우
- c1 : bool b = subset[i]->loose_erase(target) ;
- c1 : Check if the root of subset[i] has MINIMUM-1 entries
- c1 : 그렇다면 fix_shortage 함수를 사용하여 subset[i]을 수정합니다.
- c2 : 루트에 자식이 있고 타겟이 발견된 경우
- subset[i]-> ***remove_biggest*** (data[i]) ;
- if (subset[i]->data_count < MINIMUM)
- fix_shortage(i) ;
- return true ;

<br><br>

**fix_shortage funtion**

<br>

Subset[i] has only MINIMUM-1 entries인 경우
- a : Transfer an extra entry from subset[i-1]
- b : Transfer an extra entry from subset[i+1]
- c : Combine subset[i] with subset[i-1]
- d : Combine subset[i] with subset[i+1]

<br><br>

**remove_biggest funtion**

루트가 하나의 항목을 너무 적게 가질 수 있는 방식으로 B-트리에서 가장 큰 항목을 제거합니다.

<br>

1. If the root has no children, copy the last item of data into removed_entry and reduce data_count by 1.
2. If it has children, remove the biggest item from the rightmost child:
3. subset[child_count-1]->remove_biggest(removed_entry);
4. fix_shortage(child_count-1);

















