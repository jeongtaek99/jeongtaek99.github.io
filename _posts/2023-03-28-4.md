---
layout: single
title:  "자료구조[5]."
categories: "data_structure"
tag: [blog, jekyll, data_structure]
---
# 자료구조
{: .notice--info}
# Linked list
<p>Linked list는 차례로 배열된 일련의 데이터 항목으로, 각 항목은 링크로 다음 항목에 연결된다.</p>
<p>배열에 비해 추가/삭제가 용이하며 동적 할당을 기반으로 한 리스트이기 때문에 크기를 미리 지정할 필요가 없다는 장점이 있지만 특정 데이터를 찾기 위해서는 순차 탐색을 하므로 탐색 속도가 느린 단점이 있다.</p>

# Linked list의 기본 Node Class

## "node" class
<p>
c++에서의 node class 이다.
</p>

```c++
class node
{
	public:
		typedef double value_type;
	private:
		value_type data_field;
		node* link_field;
		...
}
```

## head_ptr, tail_ptr

<p>
프로그램은 포인터 변수 head_ptr을 사용해서 앞 노드를 추적할 수 있다. 또한 tail_ptr은 리스트의 마지막 노드에 대한 포인터이다.
</p>
<p>
즉 head_ptr 및 tail_ptr은 노드가 아니라 노드에 대한 포인터이다.
</p>
<p>head_ptr, tail_ptr의 선언</p>

```c++
class node
{
	public:
		typedef double value_type;
	private:
		value_type data_field;
		node* link_field;
		...
};
node* head_ptr;
node* tail_ptr;
```
헤드 포인터에 NULL을 저장하여 빈 list를 나타낸다.
```c++
head_ptr = NULL;
	//const NULL from cstdlib
```
## node constructor
노드 생성자 : 
```c++
node(
	const value_type& int_data = value_type(),
	const node* init_link = NULL)
{
	data_fild = init_data;
	link_field = init_link;
}
```
## node member funtion definitions
노드 멤버 함수 정의 : 
```c++
class node
{
	public:
		node ( ... ); // 윗부분
		void set_data(const value_type& new_data) ; //데이터 변경
		void set_link(node* new_link) ; // 링크 변경
		value_type data( ) const ; // 데이터 찾기
		const node* link( ) const ; // 링크 찾기1
		node* link( ) ; // 링크 찾기2
}
```

### 일반 포인터 node*를 리턴하는 함수
<p>예제: head_ptr -> 10 -> 7 <- second 라는 예제에서 7을 9.2로 변환</p>

```c++
node* link(){return link_field;}
node *second = head_ptr->link();
// ->은 Member selection operator로 (*head_ptr).link()와 같다.
second->set_data(9.2); // 7을 9.2로 값 변경!
```

### const 포인터 node*를 리턴하는 함수
<p>위 예제와 동일하다.</p>

```c++
const node* link() const {return link_field n;}
const node* second = head_ptr->link();
// ->은 Member selection operator로 (*head_ptr).link()와 같다.
second->set_data(9.2); // Error!! const이기 때문에 변경 불가능
```
<br><br><br><br>

# Linked List Toolkit

<p>Linked list의 Operations들을 하나씩 알아보자</p>

## Get the length of a linked list

<p>먼저 길이 함수다. 이는 링크드 리스트의 길이를 계산해주는 연산자이다.</p>
<p>헤드_ptr -> 10 -> 15 -> 7(null) 라는 리스트가 있다. 여기서 cursor가 리스트를 쭉 돌면서 수를 카운트해 answer에 값이 저장되게 하면 된다.</p>

```c++
size_t list_length(const node* head_ptr)
{
	size_t answer = 0 ;
	const node *cursor ;
	for(cursor=head_ptr; cursor!=NULL; cursor=cursor->link())
		++answer ;
	return answer ;
};
```

## Insert a node into a linked list

<p>다음은 insert다. 먼저 head부분에 insert하는 함수를 알아보자.</p>
<p>예제 : linked list는 head_ptr -> 10 -> 15 -> 7(null) 라는 리스트가 있다. 추가하려는 entry값은 13이다. 과정은 다음과 같다.</p>

<p>1. 값은 entry에 있는 값을 가지고 링크는 head_ptr의 링크를 따르는 새 노드를 만든다. </p>
<p>2. head_ptr의 링크를 새 노드로 변경한다.</p>
다음과 같이 한줄로 코드를 짤 수 있다.

```c++
void list_head_insert(node*& head_ptr, const node::value_type& entry)
{
	head_ptr = new node(entry, head_ptr) ;
}
```

<p>이번엔 head에 insert하는 것이 아닌 리스트 특정 위치에 노드를 insert해보자.</p>
<p>예제 : head_ptr -> 10 -> 15 -> 7(null) 라는 리스트가 있다. 15와 7사이에 값이 13인 entry를 추가하고자 한다. previous_ptr은 -> 15인 노드다. 과정은 다음과 같다.</p>
<p>1. 새 노드를 생성한다.</p>
<p>2. entry값을 노드에 넣는다.</p>
<p>3. 노드의 링크를 previous_ptr->link()로 한다.</p>
<p>4. previos_ptr->link()가 7이 아닌 새 노드로 가리키도록 한다.</p>
코드는 다음과 같다.

```c++
void list_insert(node* previos_ptr, const node::value_type& entry){
	node* insert_ptr;
	insert_ptr = new node;
	insert_ptr->set_data(entry);
	insert_ptr->set_link(previous_ptr->link());
	previous_ptr->set_link(insert_ptr);
}
```

## Remove a node from a linked list

## Search for data item in a linked list

## Locate a node at a certain position in a linked list

## Copy one linked list to another