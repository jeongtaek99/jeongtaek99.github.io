---
layout: single
title:  "자료구조[5]."
categories: "data_structure"
tag: [blog, jekyll, data_structure]
---
# 자료구조
{: .notice--info}
# Linked list
<p>Linked list는 차례로 배열된 일련의 데이터 항목으로, 각 항목은 링크로 다음 항목에 연결된다.</p>
<p>배열에 비해 추가/삭제가 용이하며 동적 할당을 기반으로 한 리스트이기 때문에 크기를 미리 지정할 필요가 없다는 장점이 있지만 특정 데이터를 찾기 위해서는 순차 탐색을 하므로 탐색 속도가 느린 단점이 있다.</p>

## "node" class
<p>
c++에서의 node class 이다.
</p>

```c++
class node
{
	public:
		typedef double value_type;
	private:
		value_type data_field;
		node* link_field;
		...
}
```

## head_ptr, tail_ptr

<p>
프로그램은 포인터 변수 head_ptr을 사용해서 앞 노드를 추적할 수 있다. 또한 tail_ptr은 리스트의 마지막 노드에 대한 포인터이다.
</p>
<p>
즉 head_ptr 및 tail_ptr은 노드가 아니라 노드에 대한 포인터이다.
</p>
<p>head_ptr, tail_ptr의 선언</p>

```c++
class node
{
	public:
		typedef double value_type;
	private:
		value_type data_field;
		node* link_field;
		...
};
node* head_ptr;
node* tail_ptr;
```
헤드 포인터에 NULL을 저장하여 빈 list를 나타낸다.
```c++
head_ptr = NULL;
	//const NULL from cstdlib
```
## node constructor
노드 생성자 : 
```c++
node(
	const value_type& int_data = value_type(),
	const node* init_link = NULL)
{
	data_fild = init_data;
	link_field = init_link;
}
```
### node member funtion definitions
노드 멤버 함수 정의 : 
```c++
class node
{
	public:
		node ( ... ); // 윗부분
		void set_data(const value_type& new_data) ; //
		void set_link(node* new_link) ;
		value_type data( ) const ;
		const node* link( ) const ;
		node* link( ) ;
}
```