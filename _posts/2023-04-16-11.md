---
layout: single
title:  "[리눅스]리눅스 기본 명령어2"
categories: "리눅스"
tag: [blog, jekyll, Linux, 리눅스, 우분투, ubuntu]
---
# 리눅스 기본 명령어2
{: .notice--info}

# 사용자와 그룹

리눅스는 멀티유저 시스템, 멀티 테스킹 시스템으로 사용자를 구별하고 사용자에게 적절한 지원을 할당해주는 방법이 필요하다. 사용자 계정은 사용자가 시스템에 접근할 수 있는 유일한 방법으로 관리자(root)가 사용자의 접근을 통제한다.
<br>

## 사용자 계정정보 파일

### /etc/passwd
/etc/passwd은 사용자의 계정정보를 확인할 수 있다.

비밀번호는 /etc/shadow에 암호화되어 저장된다. 출력되는 정보는 다음과 같다.
- User name : Password : UID : GID : Etc : Home Dir : Base Shell(/bin/bash)
> ![](/images/linux/1.png)
<br>

### /etc/shadow

/etc/shadow은 root 사용자만 내용을 볼 수 있으며, 출력되는 정보는 다음과 같다.

로그인 ID : 암호 : 최종 변경일 : MIN : MAX : WARNING : INACTIVE : EXPIRE : Flag
- MIN : 암호 변경 후 사용할 수 있는 최대기간
- MAX : 암호를 사용할 수 있는 최대 기간
- WARNING : 암호가 만료되기 전 경고를 시작하는 날수
- INACTIVE : 암호가 만료되어도 지정한 날수는 로그인 가능
- EXPIRE : 사용자 계정이 만료되는 날
- Flag : 향후 사용목적으로 비워둔 항목(상태)
  
<br>

### /etc/login.defs
<br>

/etc/login.defs은 사용자 계정 설정과 관련된 기본 값 정의 파일이다.
<br>

#vi /etc/login.defs를 명령하면 파일을 볼 수 있는데 여기서 UMASK는 파일 접근 권한 설정이다.
<br><br>

먼저 디렉토리 생성시 퍼미션(777), 파일 생성시 퍼미션(666)이며 2진법으로 rwx를 판별하면 디렉 : 111 111 111, 파일 110 110 110이다. 

<br>관리자의 경우 UMASK : 022, 일반 사용자의 경우 UMASK는 002이다. 접근권한을 확인하려면 퍼미션에서 UMASK를 빼주면 된다. 

- 관리자 디렉 퍼미션: 111 111 111 – 000 010 010 = 111 101 101(755) = rwx r-x r-x 
- 관리자 파일 퍼미션: 110 110 110 – 000 010 010 = 110 100 100(644) = rw- r-- r-- 
- 사용자 디렉 퍼미션 : 111 111 111 – 000 000 010 = 111 111 101(775) = rwx rwx r-x 
- 관리자 파일 퍼미션: 110 110 110 – 000 000 010 = 110 110 100(664) = rw- r-- r—
<br><br>

### /etc/group

/etc/group은 그룹정보 파일이다.

확인할 수 있는 내용은 그룹이름 : x : GID : 그룹멤버
- x : 암호화된 그룹 암호를 /etc/gshadow에 저장
- 그룹멤버 : 그룹에 속한 멤버들의 사용자 계정 이름이며 쉼표로 사용자를 구별
- /etc/gshadow 파일은 그룹이름 : 그룹암호 : 관리자 : 그룹멤버를 확인할 수 있다.
<br><br><br>

## 사용자 계정 관리
<br><br>

### 사용자 계정 추가하기
<br>

***adduser*** : 실행 시 기본 계정 정보를 자동으로 생성(홈 디렉토리도 같이 생성)
<br><br>

***useradd*** : 계정만 생성하며 기타 계정 정보는 수동으로 생성 및 설정(홈 디렉토리와 shall설정은 안되어 있다.)

 - useradd 명령시 주의사항으로 -m(home dir 생성), -s(shell 설정)을 같이 해줘야 한다.</p>

***useradd의 -D 옵션***
<br>
GROUP, HOME, INACTIVE, EXPIRE, SHELL, SKEL, CREATE_MALE_SPOOL의 기본설정 값을 확인후 수정할 수 있다. -D 다음에 -b(home), -e(EXPIRE), -f(INACTIVE), -g(GID), -s(SHELL)을 지정하여 수정할 수 있다. 이들은 /etc/default/useradd파일에 저장된다.

***중요! 여기서 SKEL은 홈 디렉토리에 복사할 기본 환경 파일의 위치다.*** 이에 대한 정보는 /etc/skel 디렉토리에 있는데 공통으로 배포할 파일을 해당 디렉토리에 파일을 만들어 놓으면 사용자 계정 생성 시에 자동으로 복사된다.

su – 계정명 : 사용자 변경 명령어로 작업 디렉토리가 해당 계정의 홈디렉토리로 이동한다.
<br><br>

## 사용자 계정정보 수정
<br>

### usermode [옵션] 로그인ID
<br>

usermode는 사용자 계정정보를 수정하는 명령어다. 홈디렉토리, 기본셸등 계정과 관련된 모든 정보를 수정 가능하다.
<br>

### ***페스워드 에이징***
페스워드 에이징은 useradd, usermod, passwd, chage 명령으로 설정가능하다. 여기서 chage는 페스워드 에이징을 관리하는 별도의 명령이다.
chage 명령
- MIN : chage -m
- MAX : chage -M
- WARINING : chage -W
- INACTIVE : chage -I(대문자 i)
- EXPIRE : chage -E(중요!)
  - ex. chage -l(소문자 엘) userid 하면 설정 내용을 확인할 수 있고 위 명령어로 수정할 수 있다.
<br>

### userdel [옵션] 로그인ID
<br>

userdel은 사용자 계정을 삭제하는 명령어다. 

옵션 : -r(홈 디렉토리를 삭제), -f(사용자가 로그인 중에도 강제로 삭제)

만약 옵션을 주지 않고 계정을 삭제하면 #rm -rf /home/사용자ID 명령을 해서 삭제해야 한다. 
결론적으로 애초에 삭제할 때 #userdel -r 사용자ID 명령으로 삭제하자.
<br><br>

## 사용자 변경하기
<br>

다른 계정 사용자로 교체할 때 사용하는 명령어.

보안 유지하기 위한 일반 사용자 su 명령어 사용 못하게 하는 방법
- #which su (su의 위치를 찾는다)
- #ls -la /bin/su (권한을 확인한다.)
- -rwsr-xr-x : 그룹 권한이 root와 일반 사용자 누구도 사용할 수 없게 설정 되어있다.
- #chmod 4750 /bin/su (권한 변경)
- $su – (허가 거부 : 일반사용자는 이제 su를 사용 못한다.)
- #chmod 4755 /bin/su (다시 원래대로 돌아가게 한다.)
<br><br>

## groupadd [옵션] 그룹명

그룹을 생성하는 명령어다.

옵션 : -g gid(그룹의 GID를 지정), -o(GID의 중복을 허용한다.) 옵션이 없으면 GID를 가장 마지막 번호의 다음 번호로 자동 설정한다.

Ex. # groupadd -g 300 -o 그룹명 (동시에 사용가능)
<br><br>

## groupmod [옵션] 그룹명

그룹 정보를 수정할 수 있다.

옵션 : -o gid(그룹의 gid를 수정), -o(중복 허용), -n 그룹명(그룹명 변경)
<br><br>

## groupdel 그룹명

그룹을 삭제한다.

옵션은 없고 바로 삭제가 된다.
<br><br>

## gpasswd [옵션] 그룹명
<br>

/etc/group과 /etc/gshadow 파일을 관리해, 그룹의 맴버 추가 및 삭제, 암호 설정에 사용됨

옵션 : -a 사용자 계정(사용자 계정을 그룹에 추가), -d 사용자 계정(사용자 계정을 그룹에서 삭제), -r(remove, 그룹 암호를 삭제)
<br><br>

## newgrp 그룹명

현재 소속 그룹을 기본 그룹이 아닌 다른 그룹으로 변경해야 할 때 사용
<br><br>

## RUID 와 EUID

RUID(Real User ID)
- 사용자를 식별하는데 사용하는 양의 정수로 0~32767까지 사용.
- UID에 따른 읽기, 쓰기, 실행 권한 설정함으로써 프로세스에 대해 소유자별로 권한부여 할 수 있으며, 이 값이 변하지 않는다.(root권한일 때는 수정가능)
- UID 확인 명령어 : id
<br><br>

EUID(Effective User ID)
- EUID는 SetUID 권한이 설정된 실행파일에 의해 변경되며 일시적으로 다른 계정의 UID를 지정해 사용할 수 있도록 해준다.
- 즉 일시적으로 파일 소유자의 권한을 얻게된다.
- EUID 확인 명령어 : whoami
<br><br>

## who [옵션]

사용자 로그인 정보 확인하기

옵션 : ***-q(로그인한 사용자 수와 계정 이름을 출력)***, -H(각 항의 제목과 함께 출력), -b(마지막으로 재시작한 날짜와 시간 출력), -m(현재 사용자 계정의 정보를 출력), -r(현재 런레벨을 출력)
<br><br>

## w [사용자 이름]

현재 시스템을 사용하는 사용자의 정보와 작업 정보를 출력한다.
<br>

> ![](/images/linux/2.png)

<br><br>

***Load Average***

시스템의 부하를 평균치, 얼마나 많은 프로세스가 실행 중 혹은 실행 대기중인지를 의미하는 수치로 명령어(uptime, top, cat /proc/loadavg)로 확인 가능

프로세스 상태 중에서 R(running)과 D(Uninterruptible waiting)은 무정전 상태 프로세스 개수를 1분, 5분, 15분 마다 평균값을 낸다.

- R : CPU에서 수행되고 있거나 실행가능한 상태

- D : I/O에 대해 대기하는 상태로 다른 어떤 일도 할 수 없음을 의미.

시스템 운영시 권장하는 평균이 70%인 0.7 이하이며 그 이상일 경우 시스템에 이상이 없는지 반드시 체크를 해야함.

load average: 0.00, 0.00, 0.00
- 첫번째 값 : 1분 동안의 평균 CPU load
- 두번째 값 : 5분 동안의 평균 CPU load
- 세번째 값 : 15분 동안의 평균 CPU load
<br><br>

### last

사용자의 이름과 로그인한 시간, 로그 아웃한 시간, 터미널 번호나 IP 주소를 출력
 
> ![](/images/linux/3.png)

- wtmp : 사용자들의 로그인 아웃 정보, 시스템 관련 정보 기록(last)

- utmp : 현재 로그인한 상태 정보를 담고 있는 로그파일(w, who, finger)
<br><br>

## root 권한 사용하기

su와 sudo 명령이 있는데 여기서 su는 사용자를 대체해 모든 권한을 부여하고, sudo는 특정 사용자에게 특정 작업만 수행하도록 권한을 부여한다.
<br>

권한 부여 방법

#vi /etc/sudoers (파일을 vi에디터로 편집한다.)

특정 사용자에게 특정 명령어만 수행할 권한 부여

- gachon 사용자에게 root 권한 중 사용자를 추가, 수정 권한 부여

- gachon ALL=/usr/sbin/adduser, /usr/sbin/usermod 추가
 
> ![](/images/linux/4.png)

<br><br>

***sudo 명령 사용 시 주의 사항***

일반 사용자에게 모든 권한을 부여하는 것은 매우 위험하다.

root 전환 안될 때는 vi 에디터로 파일을 수정해 되게 한다.
<br><br>

***sudo 명령 사용 시 설정 사항***
 
> ![](/images/linux/5.png)

<br><br>

### passwd 명령 활용하기

사용자 계정의 암호를 수정한다.

옵션 : -l 사용자 계정(스몰엘 : 지정한 계정의 암호를 잠근다.), -u사용자 계정(암호 잠금을 혜제한다.), -d 사용자 계정(암호를 삭제한다.)

Ex. # passwd -l gachon
> ![](/images/linux/6.png)
 

암호의 맨 앞에 !가 있는데 이는 암호가 잠겼음을 의미
<br><br>

## 파일 및 디렉토리의 소유자와 소유 그룹 변경하기

파일이나 디렉터리는 해당 파일이나 디렉터리를 생성한 사용자의 계정과 그룹이 소유자와 소유 그룹으로 설정

- 파일이나 디렉터리의 소유자를 변경할 필요가 있을 때 chown과 chgrp 명령을 사용
<br><br>

## chown [옵션] 사용자계정 파일명/디렉토리명

파일과 디렉토리의 소유자와 소유 그룹을 변경한다.

옵션 : -R(서브 디렉토리의 소유자와 소유 그룹도 변경한다.)

Ex. chown user2 file1(file1의 소유자를 user2로 변경)
<br><br>

## chgrp [옵션] 사용자계정 파일명/디렉토리명

파일과 디렉토리의 소유 그룹을 변경한다.

옵션 : -R(서브 디렉토리의 소유 그룹도 변경한다.)
<br><br><br><br>

# 파일 허가권

리눅스는 파일에 무단으로 접근하는 것을 방지하고 보호하는 기능을 제공한다.
- 사용자는 자신의 파일과 디렉터리의 접근 권한을 제한할 수 있다.
<br><br>

## file 파일명

지정한 파일의 종류를 알려준다.

Ex. file /etc/hosts temp (temp는 디렉, /etc/hosts는 아스키 텍스트임을 알려줌)
<br><br>

## groups 사용자명

사용자가 속한 그룹을 알려준다.
<br><br>

## 접근권한
> ![](/images/linux/7.png)

<br>

접근 권한의 표기 방법
- 사용자 카테고리별로 누가 파일을 읽고 쓰고 실행할 수 있는지를 문자로 표현한 것
- 읽기 권한은 r, 쓰기 권한은 w, 실행 권한은 x로 나타내며, 해당 권한이 없는 경우에는 -로 표기
- 사용자 카테고리별로 세 가지 권한의 부여 여부를 rwx 세 문자를 묶어서 표기
<br><br>

## chmod [옵션] 권한 모드 파일또는디렉토리명
파일이나 디렉토리의 접근 권한을 변경한다.

옵션 : -R(하위 디렉토리까지 모두 변경가능)
- 기호 모드 : 접근 권한을 변경하기 위해 문자와 기호를 사용하여 권한을 표시
- 숫자 모드 : 접근 권한을 변경하기 위해 숫자를 사용
 
> ![](/images/linux/8.png)

<br><br>

예시들
 
> ![](/images/linux/9.png)
 
> ![](/images/linux/10.png)


<br><br>

### 기본 접근 권한
<br>

일반사용자가 파일 생성 시(664), 디렉토리 생성 시(775)

root 사용자가 파일 생성 시(644), 디렉토리 생성 시(755)

## umask [옵션] [마스크 값]

기본 접근 권한을 출력하거나 변경한다.

옵션 : -S(마스크 값을 문자로 출력한다.)
 
> ![](/images/linux/11.png)

<br><br>

***마스크 값의 의미***

마스크 값은 파일이나 디렉터리 생성 시 부여하지 않을 권한을 지정 해놓는 것

- 마스크 값이 002일 경우 이는 -------w-이고, 기타 사용자에게 쓰기 권한은 부여하지 않겠다는 뜻( 파일의 최대값 : 666, 디렉토리의 최대값 : 777) - umask –s (마스크값 문자로 표시)
 
> ![](/images/linux/12.png)


예제
 
> ![](/images/linux/13.png)

<br><br>

## 특수접근 권한
관리자의 입장에서 시스템의 모든 상황을 고려해야 하기 때문에 이러한 권한 외에 몇 가지 특별한 권한을 사용하여 시스템 관리의 효율성을 높인다.
 
> ![](/images/linux/14.png)

<br>

7을 사용하면 모든 특수접근 권한을 부여하는 방식이다.
 
> ![](/images/linux/15.png)

<br>

다음과 같이 기존에 644인 파일에 특수접근 권한을 부여하면 실행권한이 없었던 파일이므로 대문자(S, S, T)로 표시한다.

 <br>

> ![](/images/linux/16.png)

<br>

이미 실행권한이 있는 경우에는 소문자(s, s, t)로 표시한다.
<br><br>

## SetUID
말 그대로 파일의 소유자 권한으로 적용하라는 뜻으로, SetUID가 설정된 파일을 실행하면 끝날 때까지 파일의 소유자의 UID가 된다.

예 : SetUID가 설정되어 있는 root 소유의 파일을 실행하면 실행이 끝날 때까지 실행하는 사람의 UID가 root의 UID “0”이 되어 root의 권한을 갖게 된다.ㄱ
<br><br>

### 실습
<br>

사용자가 비밀번호를 변경할 수 있어야 한다. 따라서 /etc/passwd에서 비밀번호를 변경하는데 파일의 접근권한은 소유자인 root 만 rw-r—r— 이지만 일반인도 비밀번호 변경이 가능한 것은 /usr/bin/passwd명령어 파일에 SetUID가 설정되어 있기 때문에 가능하다.
 
> ![](/images/linux/17.png)

<br><br>

## SetGID
파일의 그룹 권한을 적용하라는 뜻으로, SetGID가 설정된 파일을 실행하면 끝날 때까지 파일의 그룹의 GID가 된다.

<br><br>

### wall [옵션] [전송 메시지]

<br>
모든 사용자에게 메시지를 전송하는 명령어다.(그룹(tty)에 실행권한 부여 - SetGID 설정)
<br>

> ![](/images/linux/18.png)

<br>

소유 그룹이 tty이므로 /etc/group에서 확인

<br>

> ![](/images/linux/20.png)

<br>

Tty는 터미널 그룹으로 디바이스 파일로 존재한다. 

<br>

> ![](/images/linux/19.png)

- c : character device 파일

- Others의 rw 접근권한이 설정되어 있어서, 모든 사용자가 각각 터미널을 읽고 쓸 수 있지만, wall명령어는 모든 터미널에서 메시지를 보내는 명령어이므로 더 많은 권한이 필요하다. 그리고 터미널을 사용하려면 tty 그룹에 속해야만 가능

- 결론 : /usr/bin/wall에 SetGID를 설정하여 wall 명령이 실행될 때 GID가 tty의 GID(5)가 되어서 /dev/tty를 사용할 수 있게 된다.
<br><br><br>

### ***추가적인 내용 및 실습***
디렉토리에 SetGID 설정한 후 그 디렉토리 안에서 파일을 생성하면 디렉토리의 SetGID가 적용되어 생성된다.

- 결론 : root가 공용 디렉토리 만들고 SetGID를 설정하면, 어떤 사용자도 공용 디렉토리 안에 파일을 만들면 그 파일의 그룹은 root가 된다.

리눅스에서 파일의 소유자를 변경하는 것은 root만 가능하게 설정되어 있기 때문에 SetUID 에서는 SetGID처럼 하위 디렉토리에 모두 적용되는 상황이 발생되지 않는다.

따라서 디렉터리의 "SetUID"의 기능을 실행하는 건 "root"가 아니라 "일반유저"이기 때문에 소유자가 변경이 안되는 것이다.
<br><br>

***질문!***

Q : /usr/bin/passwd 파일과 /etc/passwd 파일의 차이점은 무엇인가?

A : /usr/bin/passwd은 누구나 수정가능하고 /etc/passwd은 root만 수정 가능하다.


<br><br>

***실습***
- 앞 실습에서 umask 값 설정을 변경 하였으므로 root=002, 일반 사용자=022 설정 후 실습)
- 적용 시 소유자의 접근권한 중 실행 권한이 x가 아니 S로 표시 된다.
 
> ![](/images/linux/21.png)

<br>

이번엔 SetGID를 해보자.

<br>

> ![](/images/linux/22.png)

<br>

추가로 디렉토리의 경우 디렉토리 구조가 만들어진 후 SetGID를 설정하면 해당 디렉토리에만 설정되며 그 아래있는 디렉토리에는 설정되지 않는다. – 상속X

<br>

> ![](/images/linux/23.png)

<br>

***만약 디렉토리를 만들고 SetGID를 설정하고 그 후에 하위 디렉을 만들면 그건 상속된다.***

## Sticky bit

디렉토리에 부여되는 권한으로 적용 시 모든 사용자는 읽고, 쓰기가 가능하나 삭제는 소유자만 가능하다.

- 접근 권한이 적용되면 others의 접근권한에서 실행 권한이 x가 아닌 t로 표시된다.
 
> ![](/images/linux/24.png)
다른 사용자가 해당파일을 rm file1으로 지우려고 시도할 경우 허가를 거부한다.
